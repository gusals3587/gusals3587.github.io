WEBVTT

00:00:50.740 --> 00:00:53.920
Alright, this is CS50

00:00:53.920 --> 00:00:55.320
이제는 week 1입니다.

00:00:55.320 --> 00:00:55.340
그리고 오늘 수업이 끝나면 이렇게 생긴 프로그램을 작성할 방법을 알 거에요
이제는 week 1입니다.

00:00:55.340 --> 00:01:01.300
그리고 오늘 수업이 끝나면 이렇게 생긴 프로그램을 작성할 방법을 알 거에요

00:01:01.300 --> 00:01:05.280
물론 이건 이진법이고, 컴퓨터가 결국 이해할 수 있는 유일한 ‘언어’이지만

00:01:05.280 --> 00:01:10.440
다행이도, 저번주에 배웠지만, 과거에 있던 사람들이 만들어 준 것이 워낙 많아서

00:01:10.440 --> 00:01:12.640
이 정도로 낮은 레벨에서 프로그램 작성을 하지 않아도 됩니다.

00:01:12.640 --> 00:01:15.500
엄~청 높은 개념에서 스크래치로 프로그래밍을 하거나

00:01:15.500 --> 00:01:17.880
오늘처럼 C를 통해서도 할 수 있는데요,

00:01:17.880 --> 00:01:24.240
그전에, 누군가 이 프로그램이 당신의 맥이나 컴퓨터에 들어가서 실행될 때

00:01:24.240 --> 00:01:26.240
무슨 일을 하는데 맞춰보고 싶은 사람 있나요?

00:01:26.240 --> 00:01:29.520
알아볼 수 있는 사람?

00:01:29.520 --> 00:01:31.940
몰라도 찍어보고 싶은 사람?

00:01:31.940 --> 00:01:34.620
아마도 가장 단순한 형태의 프로그램일텐데요.

00:01:34.620 --> 00:01:40.260
맞습니다, 이 프로그램이 당신의 컴퓨터의 ‘뇌’라고 불리는 CPU에서 실행될 때

00:01:40.260 --> 00:01:42.000
단순히 저걸(hello ,world) 출력해요.

00:01:42.000 --> 00:01:44.060
그럼 이걸 실제로 어떻게 작성하냐고요?

00:01:44.060 --> 00:01:46.280
그럼 일단 저번에 말한 개념들을 생각해 보죠.

00:01:46.280 --> 00:01:48.220
컴퓨터 과학에 대해 조금 광범위하게 말을 했죠.

00:01:48.220 --> 00:01:51.020
모든 문제의 해결법은 이 한 사진으로 요약이 가능한다고 말하면서

00:01:51.020 --> 00:01:53.400
어떠한 입력 (input)이 들어가면, 어떤 출력 (output)을 원하고

00:01:53.400 --> 00:01:56.420
그 중간에 입력들 가지고 무언가를 하는거죠

00:01:56.420 --> 00:02:00.720
하지만 그 중간의 무언가를 배우기 전에 입력과 출력을 나타내야했죠

00:02:00.720 --> 00:02:07.860
인간들 사이에서 컴퓨터들이 어떤 문제를 해결할 때 입력을 어떻게 표현할 지를 약속하는 거에요.

00:02:07.860 --> 00:02:13.660
그리고 결국 우리가 이용하는 핸드폰과 컴퓨터는 콘센트에 연결하여 충전하게되죠

00:02:13.660 --> 00:02:15.940
그들의 물리적 자원, 전기를 얻기 위해서요

00:02:15.940 --> 00:02:18.160
물론 어떤 애들은 배터리로 임시 저장소가 있지만

00:02:18.160 --> 00:02:19.700
결국 컴퓨터가 받는 입력은 똑같죠,

00:02:19.700 --> 00:02:22.080
전기와 연결되어있냐, 안 되어있냐

00:02:22.080 --> 00:02:24.840
0이냐, 1이냐, 참이냐, 거짓냐

00:02:24.840 --> 00:02:27.940
그래서 컴퓨터에게는 세상 전체가 그 두 개의 상태로 나눠지는 것인데

00:02:27.940 --> 00:02:31.020
우리는 그 두 개의 상태를 전구에 비유할 수 있죠

00:02:31.020 --> 00:02:31.780
켜있거나 꺼있거나,

00:02:31.780 --> 00:02:33.260
저번에는 제가 핸드폰을 꺼내서 보여줬었죠

00:02:33.260 --> 00:02:35.020
전등을 키거나 끄거나

00:02:35.020 --> 00:02:37.140
0이거나 1이거나, 참이거나, 거짓이거나

00:02:37.140 --> 00:02:41.800
물론, 전구가 1개 밖에 없으면, 0에서 1밖에 못 세지만

00:02:41.800 --> 00:02:47.340
전구가 여러개로 쭈~욱 있으면, 이들을 제가 손가락으로 한 것처럼 특정하게 배열할 수 있죠

00:02:47.340 --> 00:02:49.800
0, 1, 2, 3

00:02:49.800 --> 00:02:50.860
등등등

00:02:50.860 --> 00:02:54.120
이러면서 이진법에 대해서 말을 하기 시작했죠,

00:02:54.120 --> 00:02:58.940
예를 하나 들자면 여기 이진법 배열이 3개 있는데

00:02:58.940 --> 00:03:03.920
이들이 뭔가를 표현했는데, 그렇게 까지 세세하게 생각하지 않아도 되면서

00:03:03.920 --> 00:03:05.100
이진법을 ‘추상화’할 수 있었죠

00:03:05.100 --> 00:03:07.640
우리는 모두 다 십진법에 더 적응이 잘 되어있죠

00:03:07.640 --> 00:03:11.860
그리고 저번처럼 이 3개는 72, 73, 33을 말하고,

00:03:11.880 --> 00:03:16.620
기억나는 사람은 알 텐데, ASCII라는 숫자로 글자를 표현하는 표준 방법으로 해석하면

00:03:16.620 --> 00:03:18.120
무슨 메세지를 받았나요?

00:03:18.120 --> 00:03:22.000
네, ‘HI!’였죠, 대문자 h, 대문자 i, 느낌표

00:03:22.000 --> 00:03:26.300
그러면 이들은 이진법 숫자에서 추상화된 상위 개념이죠

00:03:26.300 --> 00:03:29.380
하지만 숫자로 글자만 표현할 수 있을 뿐만 아니고

00:03:29.380 --> 00:03:35.180
물론 결국 근본적으로 들여다 보면 전기이고, 이진법으로 나타나지만

00:03:35.180 --> 00:03:38.940
그 3개의 숫자, 72, 73, 33을 가져다가

00:03:38.940 --> 00:03:45.080
포토샵이나 사진 편집 프로그램에 넣으면 그 숫자들을

00:03:45.080 --> 00:03:48.140
빨강색 강도, 초록색 강도, 파랑색 강도로 해석하면서 (RGB)

00:03:48.140 --> 00:03:50.580
저번처럼 그 누런 색깔을 표현할 수 있었죠

00:03:50.580 --> 00:03:54.200
그럼 이제 이진법 숫자 위에 있는 개념, 색깔이 있네요

00:03:54.200 --> 00:03:57.160
그럼 이 색깔은 한 픽셀 (pixel)이지만 이제 픽셀이 여러 개가 있으면

00:03:57.180 --> 00:03:59.760
할 수 있는 것이 무엇이 있죠? 표현할 수 있는 것이 뭐가 있죠?

00:03:59.760 --> 00:04:04.240
맞아요, 이미지, 이제 계속 개념들이 올라가고 올라가면서

00:04:04.240 --> 00:04:06.920
이모티콘 같은 것도 표현할 수 있죠

00:04:06.920 --> 00:04:09.940
애들은 픽셀이 한 두개가 아니라 몇 백 개가 있고,

00:04:09.940 --> 00:04:11.400
다양한 색깔들도 포함되어있죠

00:04:11.400 --> 00:04:13.920
또한 애니메이션을 만들고 싶으면,

00:04:13.920 --> 00:04:18.620
예를 들어 핸드폰에 있는 애니모지라던가, 진짜 애니나 영화를 만들고 싶으면

00:04:18.620 --> 00:04:24.020
그들은 결국 당신의 눈에서 빠르게 지나가는 여러 개의 이미지이죠

00:04:24.020 --> 00:04:25.780
이 정도가 저번에 다룬 개념들 인데요

00:04:25.800 --> 00:04:28.180
맨 아래에서 시작하면서, 추상화 시키고, 개념을 쌓으면서

00:04:28.180 --> 00:04:35.300
입력을 표현할 수 있다고 말하고, 출력도 표현할 수 있다고 말했죠, 그 들이 무엇이든 상관 없이 

00:04:35.300 --> 00:04:37.340
그러면 지금부터, 그 낮은 레벨에 대해 생각하지 않아도 되죠,

00:04:37.340 --> 00:04:42.440
우리는 그냥 할 수 있다고 가정을 하면서, 이 개념들이 결국 기억에서 희미해져가도,

00:04:42.440 --> 00:04:44.560
누군가는 이 낮은 레벨을 할 수 있다는 것을 알면 되니까요.

00:04:44.560 --> 00:04:46.560
이게 추상화 하는 것의 장점입니다.

00:04:46.560 --> 00:04:49.500
하지만 이 검은 색 박스 안에는 ‘알고리즘’이라는 것이 들어가 있어요.

00:04:49.500 --> 00:04:50.640
비밀 특급 소스

00:04:50.640 --> 00:04:53.100
여기서 문제들이 실제로 해결되는 곳인데요

00:04:53.100 --> 00:04:57.100
우리는 이 알고리즘이 무엇인지에 대해 말할 뿐만 아니라

00:04:57.100 --> 00:04:59.140
이들이 얼마나 효율적인지에 대해 알려줄 것 입니다.

00:04:59.140 --> 00:05:02.680
이 빨간색 줄은 전화번호부에서 사람을 찾을 때

00:05:02.680 --> 00:05:05.360
단순히 앞에서부터 한 장씩 넘기는 매우 단순한 알고리즘을 나타냅니다.

00:05:05.360 --> 00:05:10.940
이게 직선인 이유는 전화번호부의 페이지 수와 종이를 넘기는 행위의 갯수에 대해

00:05:10.940 --> 00:05:12.360
1대 1 대응이 일어나기 때문입니다.

00:05:12.360 --> 00:05:14.900
1장이 늘어나면 1번 더 넘기고, 등등등..

00:05:14.900 --> 00:05:17.360
제가 두 장씩 종이를 넘기면

00:05:17.360 --> 00:05:18.980
2, 4, 6, 8—

00:05:18.980 --> 00:05:22.560
더 빠르게 찾을 수 있죠, 그래서 저 노란색 선이

00:05:22.560 --> 00:05:26.380
그래프에서 더 낮을 점을 차지합니다. 노란색 선과 빨간색 선 두 점을 잡으면,

00:05:26.380 --> 00:05:28.840
노란색이 빨간색보다 낮죠, 시간이 더 적게 걸린다는 뜻이죠

00:05:28.840 --> 00:05:30.560
하지만 노란색 알고리즘이 정답은 아니죠

00:05:30.560 --> 00:05:34.800
만약에 Mike를 찾는데 두 장씩 넘기며 찾는다면 버그가 하나 있어요

00:05:34.800 --> 00:05:36.860
발생할 수 있는 문제가 뭘까요?

00:05:36.860 --> 00:05:38.140
네, Mike를 못 찾을 수도 있죠

00:05:38.140 --> 00:05:41.460
두 장에 안에 Mike가 끼여들어 있을 수 있죠, 물론 큰 문제는 아니죠

00:05:41.460 --> 00:05:42.560
제가 고칠 수는 있으니까요,

00:05:42.560 --> 00:05:43.640
하지만 고쳐야 해야잖아요

00:05:43.640 --> 00:05:47.260
그 논리 과정을 추가적으로 넣고 넘어가면 최소한 한 장은 뒤로 가야하죠

00:05:47.260 --> 00:05:52.080
하지만 우리의 마지막 알고리즘, 혹은 우리의 직감이라고 말할 수 도 있는 방법은

00:05:52.100 --> 00:05:53.660
나누고 점령하는 방법 (divide and conquer)이었죠

00:05:53.660 --> 00:05:56.960
대략 중간 부분을 열고, 보고, 왼쪽이나 오른쪽을 가세요.

00:05:56.960 --> 00:05:58.940
그리고 이 알고리즘을 계속 반복하면서 문제가

00:05:58.940 --> 00:05:59.400
이 정도 되다가,

00:05:59.400 --> 00:05:59.920
이 정도 되다가 x 2

00:05:59.920 --> 00:06:00.440
이 정도 되다가 x 3

00:06:00.440 --> 00:06:01.020
이 정도 되다가 x 4

00:06:01.020 --> 00:06:02.320
결국 한 장만 남게 되는 것이죠

00:06:02.320 --> 00:06:04.860
그래서 효율에 대해 짚어 봤는데요.

00:06:04.860 --> 00:06:08.540
하지만 이 알고리즘을 만들기 위해서는 조금 더 정확해야 돼요.

00:06:08.540 --> 00:06:09.900
그래서 우리가 의사코드/슈도코드(pseudocode)를 소개했어요.

00:06:09.900 --> 00:06:11.380
정확한 정의는 없어요.

00:06:11.380 --> 00:06:12.700
영어이거나, 다른 언어이거나

00:06:12.700 --> 00:06:15.140
단순히 정확하고, 알기 쉬우면 되는데,

00:06:15.140 --> 00:06:18.420
의사코드를 배우면서 여러 개의 개념도 같이 배웠죠

00:06:18.420 --> 00:06:21.760
대부분 스크래치에서 한 번은 만져봤을 만한 개념들, 반복문이라던가(loop)

00:06:21.760 --> 00:06:26.320
아니면 if문/조건문(condition), 불 논리(boolean expression), 변수(variable) 등등

00:06:26.320 --> 00:06:30.860
그런 것들은 이 의사코드를 설명하면서 나왔죠

00:06:30.860 --> 00:06:34.200
하지만 솔직히, 이 설명에서도, 이 의사코드에서도

00:06:34.200 --> 00:06:35.840
만든 가정들이 여러가지가 있어요

00:06:35.840 --> 00:06:38.020
이 명령문들을 하나하나씩 읽어보면서

00:06:38.020 --> 00:06:39.560
전화번호부를 손에 가지고 있으면

00:06:39.560 --> 00:06:42.820
아마도 당신은 이 의사코드, 이 알고리즘을 시행할 수 있을 거에요.

00:06:42.820 --> 00:06:48.360
하지만 진짜로 ‘open to the middle of the phone book’라는 것이 무슨 뜻이에요?

00:06:48.360 --> 00:06:51.260
우리 모두 다 직관적인 해석이나 이해가 있지만

00:06:51.260 --> 00:06:56.500
하지만 솔직히, 이걸 어떤 어린 아이나 영어를 처음으로 배우는 사람에게

00:06:56.500 --> 00:06:58.140
‘open to the middle of the phone book’이라고 말하기 전에는

00:06:58.140 --> 00:07:00.200
원래 만들었던 가정을 몇개 내려놔야 겠죠

00:07:00.200 --> 00:07:03.920
“ok, 이 앞에 있는 물건은 1,000장, 종이 조각이 있는데,

00:07:03.920 --> 00:07:07.360
500번째 종이로 넘겨, 그리고 이걸 middle이라고 할 께…”

00:07:07.360 --> 00:07:12.080
모든 사람이 이렇게 말했다면 매우 불편하고 귀찮겠죠

00:07:12.080 --> 00:07:14.720
그래서 좀 더 포괄적인 말을 하면서 추상화하고 있죠

00:07:14.720 --> 00:07:16.400
‘open to the middle of the phone book” 처럼요

00:07:16.400 --> 00:07:17.800
하지만 이건 결국 추상화를 한거죠

00:07:17.800 --> 00:07:22.720
우리가 이상적으로 생각하기에 정확하지 않은거죠, 영어를 잘 모르는 사람이나

00:07:22.720 --> 00:07:24.560
로봇이나 컴퓨터에 말하면 더더욱 정확하지 않죠

00:07:24.560 --> 00:07:27.720
하지만 우리가 세세하게 말하면서 20 단계의 프로그램으로 만들는 것보다는

00:07:27.720 --> 00:07:30.300
더 축약적으로 12 단계의 프로그램을 만들 수 있으니까 편하죠

00:07:30.300 --> 00:07:34.300
예를 하나 더 들자면 여기서 반복문하고 if문 넣고 실행하고 있지만,

00:07:34.300 --> 00:07:36.620
이 ‘call Mike’, 이게 뭔 뜻인가요?

00:07:36.620 --> 00:07:40.460
물론 인간이 핸드폰을 어떻게 이용할 줄 안다고 가정한다면 말이 필요 없지만

00:07:40.460 --> 00:07:43.300
만약에 그/그녀가 핸드폰을 어떻게 이용하는 지에 대해 추가로 프로그래밍이 필요한다면

00:07:43.300 --> 00:07:47.640
설명을 해야하죠— 폰을 집고, 이 버튼을 누르고, 이걸이걸 누르고, 등등등

00:07:47.640 --> 00:07:50.720
그러면 결국 ‘call Mike’도 하나의 추상화죠

00:07:50.720 --> 00:07:52.460
이렇게 하위 개념을 추상화하는 것은 편리하지만,

00:07:52.460 --> 00:07:55.480
너무 많이 한다면 오히려 방해가 될 수 있어요,

00:07:55.480 --> 00:08:01.440
컴퓨터에게 말할 정도로 정확하지 않다면 특별히 더하고요

